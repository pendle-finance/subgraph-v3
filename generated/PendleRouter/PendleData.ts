// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class EtherWithdraw extends ethereum.Event {
  get params(): EtherWithdraw__Params {
    return new EtherWithdraw__Params(this);
  }
}

export class EtherWithdraw__Params {
  _event: EtherWithdraw;

  constructor(event: EtherWithdraw) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sendTo(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ForgeAdded extends ethereum.Event {
  get params(): ForgeAdded__Params {
    return new ForgeAdded__Params(this);
  }
}

export class ForgeAdded__Params {
  _event: ForgeAdded;

  constructor(event: ForgeAdded) {
    this._event = event;
  }

  get forgeId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get forgeAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ForgeFactoryValiditySet extends ethereum.Event {
  get params(): ForgeFactoryValiditySet__Params {
    return new ForgeFactoryValiditySet__Params(this);
  }
}

export class ForgeFactoryValiditySet__Params {
  _event: ForgeFactoryValiditySet;

  constructor(event: ForgeFactoryValiditySet) {
    this._event = event;
  }

  get _forgeId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get _marketFactoryId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get _valid(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class GovernanceClaimed extends ethereum.Event {
  get params(): GovernanceClaimed__Params {
    return new GovernanceClaimed__Params(this);
  }
}

export class GovernanceClaimed__Params {
  _event: GovernanceClaimed;

  constructor(event: GovernanceClaimed) {
    this._event = event;
  }

  get newGovernance(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get previousGovernance(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class InterestUpdateDeltaSet extends ethereum.Event {
  get params(): InterestUpdateDeltaSet__Params {
    return new InterestUpdateDeltaSet__Params(this);
  }
}

export class InterestUpdateDeltaSet__Params {
  _event: InterestUpdateDeltaSet;

  constructor(event: InterestUpdateDeltaSet) {
    this._event = event;
  }

  get interestUpdateDelta(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class LockParamsSet extends ethereum.Event {
  get params(): LockParamsSet__Params {
    return new LockParamsSet__Params(this);
  }
}

export class LockParamsSet__Params {
  _event: LockParamsSet;

  constructor(event: LockParamsSet) {
    this._event = event;
  }

  get lockNumerator(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get lockDenominator(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class MarketPairAdded extends ethereum.Event {
  get params(): MarketPairAdded__Params {
    return new MarketPairAdded__Params(this);
  }
}

export class MarketPairAdded__Params {
  _event: MarketPairAdded;

  constructor(event: MarketPairAdded) {
    this._event = event;
  }

  get market(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get xyt(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class ReentrancyWhitelistUpdated extends ethereum.Event {
  get params(): ReentrancyWhitelistUpdated__Params {
    return new ReentrancyWhitelistUpdated__Params(this);
  }
}

export class ReentrancyWhitelistUpdated__Params {
  _event: ReentrancyWhitelistUpdated;

  constructor(event: ReentrancyWhitelistUpdated) {
    this._event = event;
  }

  get addresses(): Array<Address> {
    return this._event.parameters[0].value.toAddressArray();
  }

  get whitelisted(): Array<boolean> {
    return this._event.parameters[1].value.toBooleanArray();
  }
}

export class TokenWithdraw extends ethereum.Event {
  get params(): TokenWithdraw__Params {
    return new TokenWithdraw__Params(this);
  }
}

export class TokenWithdraw__Params {
  _event: TokenWithdraw;

  constructor(event: TokenWithdraw) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get sendTo(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class TransferGovernancePending extends ethereum.Event {
  get params(): TransferGovernancePending__Params {
    return new TransferGovernancePending__Params(this);
  }
}

export class TransferGovernancePending__Params {
  _event: TransferGovernancePending;

  constructor(event: TransferGovernancePending) {
    this._event = event;
  }

  get pendingGovernance(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class TreasurySet extends ethereum.Event {
  get params(): TreasurySet__Params {
    return new TreasurySet__Params(this);
  }
}

export class TreasurySet__Params {
  _event: TreasurySet;

  constructor(event: TreasurySet) {
    this._event = event;
  }

  get treasury(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class PendleData__getMarketInfoResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class PendleData__getPendleYieldTokensResult {
  value0: Address;
  value1: Address;

  constructor(value0: Address, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }
}

export class PendleData extends ethereum.SmartContract {
  static bind(address: Address): PendleData {
    return new PendleData("PendleData", address);
  }

  allMarketsLength(): BigInt {
    let result = super.call(
      "allMarketsLength",
      "allMarketsLength():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_allMarketsLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allMarketsLength",
      "allMarketsLength():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  exitFee(): BigInt {
    let result = super.call("exitFee", "exitFee():(uint256)", []);

    return result[0].toBigInt();
  }

  try_exitFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("exitFee", "exitFee():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAllMarkets(): Array<Address> {
    let result = super.call("getAllMarkets", "getAllMarkets():(address[])", []);

    return result[0].toAddressArray();
  }

  try_getAllMarkets(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getAllMarkets",
      "getAllMarkets():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getEffectiveLiquidityForMarket(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): BigInt {
    let result = super.call(
      "getEffectiveLiquidityForMarket",
      "getEffectiveLiquidityForMarket(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );

    return result[0].toBigInt();
  }

  try_getEffectiveLiquidityForMarket(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getEffectiveLiquidityForMarket",
      "getEffectiveLiquidityForMarket(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getForgeAddress(param0: Bytes): Address {
    let result = super.call(
      "getForgeAddress",
      "getForgeAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toAddress();
  }

  try_getForgeAddress(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getForgeAddress",
      "getForgeAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getForgeId(param0: Address): Bytes {
    let result = super.call("getForgeId", "getForgeId(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBytes();
  }

  try_getForgeId(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall("getForgeId", "getForgeId(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getMarket(param0: Bytes, param1: Address, param2: Address): Address {
    let result = super.call(
      "getMarket",
      "getMarket(bytes32,address,address):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromAddress(param2)
      ]
    );

    return result[0].toAddress();
  }

  try_getMarket(
    param0: Bytes,
    param1: Address,
    param2: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getMarket",
      "getMarket(bytes32,address,address):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromAddress(param2)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getMarketFactoryAddress(param0: Bytes): Address {
    let result = super.call(
      "getMarketFactoryAddress",
      "getMarketFactoryAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toAddress();
  }

  try_getMarketFactoryAddress(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getMarketFactoryAddress",
      "getMarketFactoryAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getMarketFactoryId(param0: Address): Bytes {
    let result = super.call(
      "getMarketFactoryId",
      "getMarketFactoryId(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBytes();
  }

  try_getMarketFactoryId(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getMarketFactoryId",
      "getMarketFactoryId(address):(bytes32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getMarketFromKey(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): Address {
    let result = super.call(
      "getMarketFromKey",
      "getMarketFromKey(address,address,bytes32):(address)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );

    return result[0].toAddress();
  }

  try_getMarketFromKey(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getMarketFromKey",
      "getMarketFromKey(address,address,bytes32):(address)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getMarketInfo(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): PendleData__getMarketInfoResult {
    let result = super.call(
      "getMarketInfo",
      "getMarketInfo(address,address,bytes32):(uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );

    return new PendleData__getMarketInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getMarketInfo(
    _tokenIn: Address,
    _tokenOut: Address,
    _marketFactoryId: Bytes
  ): ethereum.CallResult<PendleData__getMarketInfoResult> {
    let result = super.tryCall(
      "getMarketInfo",
      "getMarketInfo(address,address,bytes32):(uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromFixedBytes(_marketFactoryId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PendleData__getMarketInfoResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getPendleYieldTokens(
    _forgeId: Bytes,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): PendleData__getPendleYieldTokensResult {
    let result = super.call(
      "getPendleYieldTokens",
      "getPendleYieldTokens(bytes32,address,uint256):(address,address)",
      [
        ethereum.Value.fromFixedBytes(_forgeId),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );

    return new PendleData__getPendleYieldTokensResult(
      result[0].toAddress(),
      result[1].toAddress()
    );
  }

  try_getPendleYieldTokens(
    _forgeId: Bytes,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): ethereum.CallResult<PendleData__getPendleYieldTokensResult> {
    let result = super.tryCall(
      "getPendleYieldTokens",
      "getPendleYieldTokens(bytes32,address,uint256):(address,address)",
      [
        ethereum.Value.fromFixedBytes(_forgeId),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PendleData__getPendleYieldTokensResult(
        value[0].toAddress(),
        value[1].toAddress()
      )
    );
  }

  governance(): Address {
    let result = super.call("governance", "governance():(address)", []);

    return result[0].toAddress();
  }

  try_governance(): ethereum.CallResult<Address> {
    let result = super.tryCall("governance", "governance():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  interestUpdateDelta(): BigInt {
    let result = super.call(
      "interestUpdateDelta",
      "interestUpdateDelta():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_interestUpdateDelta(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "interestUpdateDelta",
      "interestUpdateDelta():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isMarket(param0: Address): boolean {
    let result = super.call("isMarket", "isMarket(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_isMarket(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isMarket", "isMarket(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isValidXYT(
    _forge: Address,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): boolean {
    let result = super.call(
      "isValidXYT",
      "isValidXYT(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_forge),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );

    return result[0].toBoolean();
  }

  try_isValidXYT(
    _forge: Address,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isValidXYT",
      "isValidXYT(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(_forge),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isValidXYT1(
    _forgeId: Bytes,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): boolean {
    let result = super.call(
      "isValidXYT",
      "isValidXYT(bytes32,address,uint256):(bool)",
      [
        ethereum.Value.fromFixedBytes(_forgeId),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );

    return result[0].toBoolean();
  }

  try_isValidXYT1(
    _forgeId: Bytes,
    _underlyingAsset: Address,
    _expiry: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isValidXYT",
      "isValidXYT(bytes32,address,uint256):(bool)",
      [
        ethereum.Value.fromFixedBytes(_forgeId),
        ethereum.Value.fromAddress(_underlyingAsset),
        ethereum.Value.fromUnsignedBigInt(_expiry)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isXyt(param0: Address): boolean {
    let result = super.call("isXyt", "isXyt(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_isXyt(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isXyt", "isXyt(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lockDenominator(): BigInt {
    let result = super.call(
      "lockDenominator",
      "lockDenominator():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lockDenominator(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockDenominator",
      "lockDenominator():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockNumerator(): BigInt {
    let result = super.call("lockNumerator", "lockNumerator():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockNumerator(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockNumerator",
      "lockNumerator():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  otTokens(param0: Bytes, param1: Address, param2: BigInt): Address {
    let result = super.call(
      "otTokens",
      "otTokens(bytes32,address,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2)
      ]
    );

    return result[0].toAddress();
  }

  try_otTokens(
    param0: Bytes,
    param1: Address,
    param2: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "otTokens",
      "otTokens(bytes32,address,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  pendingGovernance(): Address {
    let result = super.call(
      "pendingGovernance",
      "pendingGovernance():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_pendingGovernance(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "pendingGovernance",
      "pendingGovernance():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reentrancyWhitelisted(param0: Address): boolean {
    let result = super.call(
      "reentrancyWhitelisted",
      "reentrancyWhitelisted(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_reentrancyWhitelisted(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "reentrancyWhitelisted",
      "reentrancyWhitelisted(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  router(): Address {
    let result = super.call("router", "router():(address)", []);

    return result[0].toAddress();
  }

  try_router(): ethereum.CallResult<Address> {
    let result = super.tryCall("router", "router():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  swapFee(): BigInt {
    let result = super.call("swapFee", "swapFee():(uint256)", []);

    return result[0].toBigInt();
  }

  try_swapFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("swapFee", "swapFee():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  treasury(): Address {
    let result = super.call("treasury", "treasury():(address)", []);

    return result[0].toAddress();
  }

  try_treasury(): ethereum.CallResult<Address> {
    let result = super.tryCall("treasury", "treasury():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  validForgeFactoryPair(param0: Bytes, param1: Bytes): boolean {
    let result = super.call(
      "validForgeFactoryPair",
      "validForgeFactoryPair(bytes32,bytes32):(bool)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromFixedBytes(param1)
      ]
    );

    return result[0].toBoolean();
  }

  try_validForgeFactoryPair(
    param0: Bytes,
    param1: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "validForgeFactoryPair",
      "validForgeFactoryPair(bytes32,bytes32):(bool)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromFixedBytes(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  xytTokens(param0: Bytes, param1: Address, param2: BigInt): Address {
    let result = super.call(
      "xytTokens",
      "xytTokens(bytes32,address,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2)
      ]
    );

    return result[0].toAddress();
  }

  try_xytTokens(
    param0: Bytes,
    param1: Address,
    param2: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "xytTokens",
      "xytTokens(bytes32,address,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _governance(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _treasury(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddForgeCall extends ethereum.Call {
  get inputs(): AddForgeCall__Inputs {
    return new AddForgeCall__Inputs(this);
  }

  get outputs(): AddForgeCall__Outputs {
    return new AddForgeCall__Outputs(this);
  }
}

export class AddForgeCall__Inputs {
  _call: AddForgeCall;

  constructor(call: AddForgeCall) {
    this._call = call;
  }

  get _forgeId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _forgeAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddForgeCall__Outputs {
  _call: AddForgeCall;

  constructor(call: AddForgeCall) {
    this._call = call;
  }
}

export class AddMarketCall extends ethereum.Call {
  get inputs(): AddMarketCall__Inputs {
    return new AddMarketCall__Inputs(this);
  }

  get outputs(): AddMarketCall__Outputs {
    return new AddMarketCall__Outputs(this);
  }
}

export class AddMarketCall__Inputs {
  _call: AddMarketCall;

  constructor(call: AddMarketCall) {
    this._call = call;
  }

  get _marketFactoryId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _xyt(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _market(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class AddMarketCall__Outputs {
  _call: AddMarketCall;

  constructor(call: AddMarketCall) {
    this._call = call;
  }
}

export class AddMarketFactoryCall extends ethereum.Call {
  get inputs(): AddMarketFactoryCall__Inputs {
    return new AddMarketFactoryCall__Inputs(this);
  }

  get outputs(): AddMarketFactoryCall__Outputs {
    return new AddMarketFactoryCall__Outputs(this);
  }
}

export class AddMarketFactoryCall__Inputs {
  _call: AddMarketFactoryCall;

  constructor(call: AddMarketFactoryCall) {
    this._call = call;
  }

  get _marketFactoryId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _marketFactoryAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddMarketFactoryCall__Outputs {
  _call: AddMarketFactoryCall;

  constructor(call: AddMarketFactoryCall) {
    this._call = call;
  }
}

export class ClaimGovernanceCall extends ethereum.Call {
  get inputs(): ClaimGovernanceCall__Inputs {
    return new ClaimGovernanceCall__Inputs(this);
  }

  get outputs(): ClaimGovernanceCall__Outputs {
    return new ClaimGovernanceCall__Outputs(this);
  }
}

export class ClaimGovernanceCall__Inputs {
  _call: ClaimGovernanceCall;

  constructor(call: ClaimGovernanceCall) {
    this._call = call;
  }
}

export class ClaimGovernanceCall__Outputs {
  _call: ClaimGovernanceCall;

  constructor(call: ClaimGovernanceCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _router(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class SetForgeFactoryValidityCall extends ethereum.Call {
  get inputs(): SetForgeFactoryValidityCall__Inputs {
    return new SetForgeFactoryValidityCall__Inputs(this);
  }

  get outputs(): SetForgeFactoryValidityCall__Outputs {
    return new SetForgeFactoryValidityCall__Outputs(this);
  }
}

export class SetForgeFactoryValidityCall__Inputs {
  _call: SetForgeFactoryValidityCall;

  constructor(call: SetForgeFactoryValidityCall) {
    this._call = call;
  }

  get _forgeId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _marketFactoryId(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _valid(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class SetForgeFactoryValidityCall__Outputs {
  _call: SetForgeFactoryValidityCall;

  constructor(call: SetForgeFactoryValidityCall) {
    this._call = call;
  }
}

export class SetInterestUpdateDeltaCall extends ethereum.Call {
  get inputs(): SetInterestUpdateDeltaCall__Inputs {
    return new SetInterestUpdateDeltaCall__Inputs(this);
  }

  get outputs(): SetInterestUpdateDeltaCall__Outputs {
    return new SetInterestUpdateDeltaCall__Outputs(this);
  }
}

export class SetInterestUpdateDeltaCall__Inputs {
  _call: SetInterestUpdateDeltaCall;

  constructor(call: SetInterestUpdateDeltaCall) {
    this._call = call;
  }

  get _interestUpdateDelta(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetInterestUpdateDeltaCall__Outputs {
  _call: SetInterestUpdateDeltaCall;

  constructor(call: SetInterestUpdateDeltaCall) {
    this._call = call;
  }
}

export class SetLockParamsCall extends ethereum.Call {
  get inputs(): SetLockParamsCall__Inputs {
    return new SetLockParamsCall__Inputs(this);
  }

  get outputs(): SetLockParamsCall__Outputs {
    return new SetLockParamsCall__Outputs(this);
  }
}

export class SetLockParamsCall__Inputs {
  _call: SetLockParamsCall;

  constructor(call: SetLockParamsCall) {
    this._call = call;
  }

  get _lockNumerator(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _lockDenominator(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetLockParamsCall__Outputs {
  _call: SetLockParamsCall;

  constructor(call: SetLockParamsCall) {
    this._call = call;
  }
}

export class SetMarketFeesCall extends ethereum.Call {
  get inputs(): SetMarketFeesCall__Inputs {
    return new SetMarketFeesCall__Inputs(this);
  }

  get outputs(): SetMarketFeesCall__Outputs {
    return new SetMarketFeesCall__Outputs(this);
  }
}

export class SetMarketFeesCall__Inputs {
  _call: SetMarketFeesCall;

  constructor(call: SetMarketFeesCall) {
    this._call = call;
  }

  get _swapFee(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _exitFee(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetMarketFeesCall__Outputs {
  _call: SetMarketFeesCall;

  constructor(call: SetMarketFeesCall) {
    this._call = call;
  }
}

export class SetReentrancyWhitelistCall extends ethereum.Call {
  get inputs(): SetReentrancyWhitelistCall__Inputs {
    return new SetReentrancyWhitelistCall__Inputs(this);
  }

  get outputs(): SetReentrancyWhitelistCall__Outputs {
    return new SetReentrancyWhitelistCall__Outputs(this);
  }
}

export class SetReentrancyWhitelistCall__Inputs {
  _call: SetReentrancyWhitelistCall;

  constructor(call: SetReentrancyWhitelistCall) {
    this._call = call;
  }

  get addresses(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get whitelisted(): Array<boolean> {
    return this._call.inputValues[1].value.toBooleanArray();
  }
}

export class SetReentrancyWhitelistCall__Outputs {
  _call: SetReentrancyWhitelistCall;

  constructor(call: SetReentrancyWhitelistCall) {
    this._call = call;
  }
}

export class SetTreasuryCall extends ethereum.Call {
  get inputs(): SetTreasuryCall__Inputs {
    return new SetTreasuryCall__Inputs(this);
  }

  get outputs(): SetTreasuryCall__Outputs {
    return new SetTreasuryCall__Outputs(this);
  }
}

export class SetTreasuryCall__Inputs {
  _call: SetTreasuryCall;

  constructor(call: SetTreasuryCall) {
    this._call = call;
  }

  get _treasury(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTreasuryCall__Outputs {
  _call: SetTreasuryCall;

  constructor(call: SetTreasuryCall) {
    this._call = call;
  }
}

export class StoreTokensCall extends ethereum.Call {
  get inputs(): StoreTokensCall__Inputs {
    return new StoreTokensCall__Inputs(this);
  }

  get outputs(): StoreTokensCall__Outputs {
    return new StoreTokensCall__Outputs(this);
  }
}

export class StoreTokensCall__Inputs {
  _call: StoreTokensCall;

  constructor(call: StoreTokensCall) {
    this._call = call;
  }

  get _forgeId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _ot(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _xyt(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _underlyingAsset(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _expiry(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class StoreTokensCall__Outputs {
  _call: StoreTokensCall;

  constructor(call: StoreTokensCall) {
    this._call = call;
  }
}

export class TransferGovernanceCall extends ethereum.Call {
  get inputs(): TransferGovernanceCall__Inputs {
    return new TransferGovernanceCall__Inputs(this);
  }

  get outputs(): TransferGovernanceCall__Outputs {
    return new TransferGovernanceCall__Outputs(this);
  }
}

export class TransferGovernanceCall__Inputs {
  _call: TransferGovernanceCall;

  constructor(call: TransferGovernanceCall) {
    this._call = call;
  }

  get _governance(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferGovernanceCall__Outputs {
  _call: TransferGovernanceCall;

  constructor(call: TransferGovernanceCall) {
    this._call = call;
  }
}

export class UpdateMarketInfoCall extends ethereum.Call {
  get inputs(): UpdateMarketInfoCall__Inputs {
    return new UpdateMarketInfoCall__Inputs(this);
  }

  get outputs(): UpdateMarketInfoCall__Outputs {
    return new UpdateMarketInfoCall__Outputs(this);
  }
}

export class UpdateMarketInfoCall__Inputs {
  _call: UpdateMarketInfoCall;

  constructor(call: UpdateMarketInfoCall) {
    this._call = call;
  }

  get _xyt(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _marketFactory(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class UpdateMarketInfoCall__Outputs {
  _call: UpdateMarketInfoCall;

  constructor(call: UpdateMarketInfoCall) {
    this._call = call;
  }
}

export class UpdateMarketInfo1Call extends ethereum.Call {
  get inputs(): UpdateMarketInfo1Call__Inputs {
    return new UpdateMarketInfo1Call__Inputs(this);
  }

  get outputs(): UpdateMarketInfo1Call__Outputs {
    return new UpdateMarketInfo1Call__Outputs(this);
  }
}

export class UpdateMarketInfo1Call__Inputs {
  _call: UpdateMarketInfo1Call;

  constructor(call: UpdateMarketInfo1Call) {
    this._call = call;
  }

  get _xyt(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _marketFactoryId(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class UpdateMarketInfo1Call__Outputs {
  _call: UpdateMarketInfo1Call;

  constructor(call: UpdateMarketInfo1Call) {
    this._call = call;
  }
}

export class WithdrawEtherCall extends ethereum.Call {
  get inputs(): WithdrawEtherCall__Inputs {
    return new WithdrawEtherCall__Inputs(this);
  }

  get outputs(): WithdrawEtherCall__Outputs {
    return new WithdrawEtherCall__Outputs(this);
  }
}

export class WithdrawEtherCall__Inputs {
  _call: WithdrawEtherCall;

  constructor(call: WithdrawEtherCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get sendTo(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawEtherCall__Outputs {
  _call: WithdrawEtherCall;

  constructor(call: WithdrawEtherCall) {
    this._call = call;
  }
}

export class WithdrawTokenCall extends ethereum.Call {
  get inputs(): WithdrawTokenCall__Inputs {
    return new WithdrawTokenCall__Inputs(this);
  }

  get outputs(): WithdrawTokenCall__Outputs {
    return new WithdrawTokenCall__Outputs(this);
  }
}

export class WithdrawTokenCall__Inputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get sendTo(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class WithdrawTokenCall__Outputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }
}
