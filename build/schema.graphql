type Forge @entity {
  id: ID! #address
  forgeId: String! #Human Readable ID
}

type MarketFactory @entity {
  id: ID! #ForgeId
  address: String! #Market Factory ID
}

type YieldContract @entity {
  #Forge ID + underlying asset + expiry
  id: ID!
  forgeId: String!

  # Underlying Asset Token
  underlyingAsset: Token!
  # XYT - Future Yield Token
  xyt: Token!
  # OT - Ownership Token
  ot: Token!
  #Expiry of Yield Tokens
  expiry: BigInt!

  # Total mint transactions
  mintTxCount: BigInt!
  # Total redeem transactions
  redeemTxCount: BigInt!
  # Total interest settled transactions
  interestSettledTxCount: BigInt!

  #Volume
  mintVolume: BigDecimal!
  redeemVolume: BigDecimal!
  interestSettledVolume: BigDecimal!
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  # used for other stats like marketcap
  totalSupply: BigInt!

  # token specific volume
  tradeVolume: BigDecimal!
  tradeVolumeUSD: BigDecimal!

  mintVolume: BigDecimal!
  mintVolumeUSD: BigDecimal!

  redeemVolume: BigDecimal!
  redeemVolumeUSD: BigDecimal!

  # transactions across all pairs
  txCount: BigInt!

  # liquidity across all pairs
  totalLiquidity: BigDecimal!
}

type MintYieldToken @entity {
  # transaction hash
  id: ID!
  blockNumber: BigInt!
  timestamp: BigInt!

  forgeId: String!
  amountMinted: BigDecimal!
  expiry: BigInt!
  from: Bytes! # the EOA that initiated the txn
  # Underlying Asset Token
  underlyingAsset: Token!
  yieldContract: YieldContract!
}

type RedeemYieldToken @entity {
  # transaction hash
  id: ID!
  blockNumber: BigInt!
  timestamp: BigInt!

  forgeId: String!
  amountRedeemed: BigDecimal!
  expiry: BigInt!
  from: Bytes! # the EOA that initiated the txn
  # Underlying Asset Token
  underlyingAsset: Token!
  yieldContract: YieldContract!
}

type Pair @entity {
  # pair address
  id: ID!

  # mirrored from the smart contract
  token0: Token! #xyt Token
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!

  # derived liquidity
  reserveUSD: BigDecimal!
  # Price in terms of the asset pair
  token0Price: BigDecimal!
  token1Price: BigDecimal!

  # lifetime volume stats
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  txCount: BigInt!
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal

  # creation stats
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # derived fields
  # pairHourData: [PairHourData!]! @derivedFrom(field: "pair")
  # liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "pair")
  # liquidityPositionSnapshots: [LiquidityPositionSnapshot!]! @derivedFrom(field: "pair")
  # mints: [Mint!]! @derivedFrom(field: "pair")
  # burns: [Burn!]! @derivedFrom(field: "pair")
  # swaps: [Swap!]! @derivedFrom(field: "pair")
}

type Swap @entity {
  # transaction hash
  id: ID!
  # transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the Swap event
  sender: Bytes!
  from: Bytes! # the EOA that initiated the txn
  inToken: Token!
  outToken: Token!
  inAmount: BigDecimal!
  outAmount: BigDecimal!
  to: Bytes!
  logIndex: BigInt
  feesCollected: BigDecimal!
  feesCollectedUSD: BigDecimal!

  # derived info
  amountUSD: BigDecimal!
}

type User @entity {
  id: ID!
  liquidityPositions: [LiquidityPosition!] @derivedFrom(field: "user")
  usdSwapped: BigDecimal!
}

type LiquidityPosition @entity {
  id: ID!
  user: User!
  pair: Pair!
  liquidityTokenBalance: BigDecimal!
  supplyOfPoolOwnedPercentage: BigDecimal! # the total of LP tokens owned/ LP token supply in percentage
}

# saved over time for return calculations
type LiquidityPositionSnapshot @entity {
  id: ID!
  liquidityPosition: LiquidityPosition!
  timestamp: Int! # saved for fast historical lookups
  block: Int! # saved for fast historical lookups
  user: User! # reference to user
  pair: Pair! # reference to pair
  token0Amount: BigDecimal! #the amount of token0 gained/removed
  token1Amount: BigDecimal! #the amount of token1 gained/removed
  token0PriceUSD: BigDecimal! # snapshot of token0 price
  token1PriceUSD: BigDecimal! # snapshot of token1 price
  reserve0: BigDecimal! # snapshot of pair token0 reserves
  reserve1: BigDecimal! # snapshot of pair token1 reserves
  reserveUSD: BigDecimal! # snapshot of pair reserves in USD
  liquidityTokenTotalSupply: BigDecimal! # snapshot of pool token supply
  liquidityTokenBalance: BigDecimal! # snapshot of users pool token balance
  liquidityTokenMoved: BigDecimal! # the amount of LP tokens gained/removed
  type: String! # either 'add' or 'remove' to specify if adding or removing liquidity
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!
  # This is not the reverse of Mint.transaction; it is only used to
  # track incomplete mints (similar for burns and swaps)
  lpMints: [MintLPToken]!
  lpBurns: [BurnLPToken]!
  swaps: [Swap]!
  mintYieldTokens: [MintYieldToken]!
  redeemYieldTokens: [RedeemYieldToken]!
}

type MintLPToken @entity {
  # transaction hash + "-" + index in mints Transaction array
  id: ID!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the primary Transfer event
  to: Bytes!
  liquidity: BigDecimal!

  # populated from the Mint event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal
  logIndex: BigInt
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type BurnLPToken @entity {
  # transaction hash + "-" + index in mints Transaction array
  id: ID!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the primary Transfer event
  liquidity: BigDecimal!

  # populated from the Burn event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal
  to: Bytes
  logIndex: BigInt
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal

  # mark uncomplete in ETH case
  needsComplete: Boolean!

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type PendleData @entity {
  id: ID!
  swapFee: BigDecimal!
  exitFee: BigDecimal!
}

type LiquidityPool @entity {
  # transaction hash
  id: ID!
  # transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!
  type: String! # Join or Exit only

  # populated from the LiquidityPool event
  from: Bytes! # the EOA that initiated the txn
  inToken0: Token!
  inToken1: Token!
  inAmount0: BigDecimal!
  inAmount1: BigDecimal!
  feesCollected: BigDecimal!
  feesCollectedUSD: BigDecimal!

  # derived info
  amountUSD: BigDecimal!
}